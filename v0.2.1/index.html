<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>BinaryBuilderBase.jl Documentation · BinaryBuilderBase.jl</title><link href="https://fonts.googleapis.com/css?family=Lato|Roboto+Mono" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.11.2/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.11.2/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.11.2/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.11.1/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL="."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="assets/documenter.js"></script><script src="siteinfo.js"></script><script src="../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="assets/themes/documenter-dark.css" data-theme-name="documenter-dark"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="assets/themeswap.js"></script></head><body><div id="documenter"><nav class="docs-sidebar"><div class="docs-package-name"><span class="docs-autofit">BinaryBuilderBase.jl</span></div><form class="docs-search" action="search/"><input class="docs-search-query" id="documenter-search-query" name="q" type="text" placeholder="Search docs"/></form><ul class="docs-menu"><li class="is-active"><a class="tocitem" href>BinaryBuilderBase.jl Documentation</a><ul class="internal"><li><a class="tocitem" href="#Index-1"><span>Index</span></a></li><li><a class="tocitem" href="#Types-1"><span>Types</span></a></li><li><a class="tocitem" href="#Functions-1"><span>Functions</span></a></li></ul></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><nav class="breadcrumb"><ul class="is-hidden-mobile"><li class="is-active"><a href>BinaryBuilderBase.jl Documentation</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>BinaryBuilderBase.jl Documentation</a></li></ul></nav><div class="docs-right"><a class="docs-edit-link" href="https://github.com/JuliaPackaging/BinaryBuilderBase.jl/blob/master/docs/src/index.md" title="Edit on GitHub"><span class="docs-icon fab"></span><span class="docs-label is-hidden-touch">Edit on GitHub</span></a><a class="docs-settings-button fas fa-cog" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-sidebar-button fa fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a></div></header><article class="content" id="documenter-page"><h1 id="BinaryBuilderBase.jl-Documentation-1"><a class="docs-heading-anchor" href="#BinaryBuilderBase.jl-Documentation-1">BinaryBuilderBase.jl Documentation</a><a class="docs-heading-anchor-permalink" href="#BinaryBuilderBase.jl-Documentation-1" title="Permalink"></a></h1><p>This is the reference documentation of <a href="https://github.com/JuliaPackaging/BinaryBuilderBase.jl"><code>BinaryBuilderBase.jl</code></a>.</p><h2 id="Index-1"><a class="docs-heading-anchor" href="#Index-1">Index</a><a class="docs-heading-anchor-permalink" href="#Index-1" title="Permalink"></a></h2><ul><li><a href="#BinaryBuilderBase.AbstractDependency"><code>BinaryBuilderBase.AbstractDependency</code></a></li><li><a href="#BinaryBuilderBase.AbstractSource"><code>BinaryBuilderBase.AbstractSource</code></a></li><li><a href="#BinaryBuilderBase.AnyPlatform"><code>BinaryBuilderBase.AnyPlatform</code></a></li><li><a href="#BinaryBuilderBase.ArchiveSource"><code>BinaryBuilderBase.ArchiveSource</code></a></li><li><a href="#BinaryBuilderBase.BuildDependency"><code>BinaryBuilderBase.BuildDependency</code></a></li><li><a href="#BinaryBuilderBase.Dependency"><code>BinaryBuilderBase.Dependency</code></a></li><li><a href="#BinaryBuilderBase.DirectorySource"><code>BinaryBuilderBase.DirectorySource</code></a></li><li><a href="#BinaryBuilderBase.DockerRunner"><code>BinaryBuilderBase.DockerRunner</code></a></li><li><a href="#BinaryBuilderBase.ExecutableProduct"><code>BinaryBuilderBase.ExecutableProduct</code></a></li><li><a href="#BinaryBuilderBase.ExtendedPlatform"><code>BinaryBuilderBase.ExtendedPlatform</code></a></li><li><a href="#BinaryBuilderBase.FileProduct"><code>BinaryBuilderBase.FileProduct</code></a></li><li><a href="#BinaryBuilderBase.FileSource"><code>BinaryBuilderBase.FileSource</code></a></li><li><a href="#BinaryBuilderBase.FrameworkProduct"><code>BinaryBuilderBase.FrameworkProduct</code></a></li><li><a href="#BinaryBuilderBase.GitSource"><code>BinaryBuilderBase.GitSource</code></a></li><li><a href="#BinaryBuilderBase.LibraryProduct"><code>BinaryBuilderBase.LibraryProduct</code></a></li><li><a href="#BinaryBuilderBase.Product"><code>BinaryBuilderBase.Product</code></a></li><li><a href="#BinaryBuilderBase.UserNSRunner"><code>BinaryBuilderBase.UserNSRunner</code></a></li><li><a href="#BinaryBuilderBase.abi_agnostic-Union{Tuple{P}, Tuple{P}} where P&lt;:Platform"><code>BinaryBuilderBase.abi_agnostic</code></a></li><li><a href="#BinaryBuilderBase.accept_apple_sdk-Tuple{IO,IO}"><code>BinaryBuilderBase.accept_apple_sdk</code></a></li><li><a href="#BinaryBuilderBase.artifact_name-Tuple{CompilerShard}"><code>BinaryBuilderBase.artifact_name</code></a></li><li><a href="#BinaryBuilderBase.bindir-Tuple{Prefix}"><code>BinaryBuilderBase.bindir</code></a></li><li><a href="#BinaryBuilderBase.choose_shards-Tuple{Platform}"><code>BinaryBuilderBase.choose_shards</code></a></li><li><a href="#BinaryBuilderBase.chown_cleanup-Tuple{DockerRunner}"><code>BinaryBuilderBase.chown_cleanup</code></a></li><li><a href="#BinaryBuilderBase.compress_dir-Tuple{AbstractString}"><code>BinaryBuilderBase.compress_dir</code></a></li><li><a href="#BinaryBuilderBase.create_and_bind_mutable_artifact!-Tuple{Function,String}"><code>BinaryBuilderBase.create_and_bind_mutable_artifact!</code></a></li><li><a href="#BinaryBuilderBase.download_all_artifacts-Tuple{}"><code>BinaryBuilderBase.download_all_artifacts</code></a></li><li><a href="#BinaryBuilderBase.download_source"><code>BinaryBuilderBase.download_source</code></a></li><li><a href="#BinaryBuilderBase.expand_cxxstring_abis-Tuple{Platform}"><code>BinaryBuilderBase.expand_cxxstring_abis</code></a></li><li><a href="#BinaryBuilderBase.expand_gfortran_versions-Tuple{Platform}"><code>BinaryBuilderBase.expand_gfortran_versions</code></a></li><li><a href="#BinaryBuilderBase.expand_microarchitectures-Tuple{Array{#s518,1} where #s518&lt;:Platform}"><code>BinaryBuilderBase.expand_microarchitectures</code></a></li><li><a href="#BinaryBuilderBase.expand_microarchitectures-Tuple{Platform}"><code>BinaryBuilderBase.expand_microarchitectures</code></a></li><li><a href="#BinaryBuilderBase.gcc_version-Tuple{Platform,Array{BinaryBuilderBase.GCCBuild,1}}"><code>BinaryBuilderBase.gcc_version</code></a></li><li><a href="#BinaryBuilderBase.generate_compiler_wrappers!-Tuple{Platform}"><code>BinaryBuilderBase.generate_compiler_wrappers!</code></a></li><li><a href="#BinaryBuilderBase.generate_per_uid_squashfs"><code>BinaryBuilderBase.generate_per_uid_squashfs</code></a></li><li><a href="#BinaryBuilderBase.get_concrete_platform-Tuple{Platform}"><code>BinaryBuilderBase.get_concrete_platform</code></a></li><li><a href="#BinaryBuilderBase.get_concrete_platform-Tuple{Platform,Array{CompilerShard,1}}"><code>BinaryBuilderBase.get_concrete_platform</code></a></li><li><a href="#BinaryBuilderBase.get_mutable_artifact_path-Tuple{String}"><code>BinaryBuilderBase.get_mutable_artifact_path</code></a></li><li><a href="#BinaryBuilderBase.getgid-Tuple{}"><code>BinaryBuilderBase.getgid</code></a></li><li><a href="#BinaryBuilderBase.getuid-Tuple{}"><code>BinaryBuilderBase.getuid</code></a></li><li><a href="#BinaryBuilderBase.import_docker_image-Tuple{CompilerShard,String}"><code>BinaryBuilderBase.import_docker_image</code></a></li><li><a href="#BinaryBuilderBase.includedir-Tuple{Prefix}"><code>BinaryBuilderBase.includedir</code></a></li><li><a href="#BinaryBuilderBase.is_ecryptfs-Tuple{AbstractString}"><code>BinaryBuilderBase.is_ecryptfs</code></a></li><li><a href="#BinaryBuilderBase.is_mounted-Tuple{CompilerShard,AbstractString}"><code>BinaryBuilderBase.is_mounted</code></a></li><li><a href="#BinaryBuilderBase.libdirs"><code>BinaryBuilderBase.libdirs</code></a></li><li><a href="#BinaryBuilderBase.locate-Tuple{FileProduct,Prefix}"><code>BinaryBuilderBase.locate</code></a></li><li><a href="#BinaryBuilderBase.locate-Tuple{LibraryProduct,Prefix}"><code>BinaryBuilderBase.locate</code></a></li><li><a href="#BinaryBuilderBase.locate-Tuple{ExecutableProduct,Prefix}"><code>BinaryBuilderBase.locate</code></a></li><li><a href="#BinaryBuilderBase.logdir-Tuple{Prefix}"><code>BinaryBuilderBase.logdir</code></a></li><li><a href="#BinaryBuilderBase.macos_sdk_already_installed-Tuple{}"><code>BinaryBuilderBase.macos_sdk_already_installed</code></a></li><li><a href="#BinaryBuilderBase.map_target-Tuple{CompilerShard}"><code>BinaryBuilderBase.map_target</code></a></li><li><a href="#BinaryBuilderBase.mount-Tuple{CompilerShard,AbstractString}"><code>BinaryBuilderBase.mount</code></a></li><li><a href="#BinaryBuilderBase.platform_envs-Tuple{Platform,AbstractString}"><code>BinaryBuilderBase.platform_envs</code></a></li><li><a href="#BinaryBuilderBase.preferred_cxxstring_abi-Tuple{Platform,CompilerShard}"><code>BinaryBuilderBase.preferred_cxxstring_abi</code></a></li><li><a href="#BinaryBuilderBase.preferred_libgfortran_version-Tuple{Platform,CompilerShard}"><code>BinaryBuilderBase.preferred_libgfortran_version</code></a></li><li><a href="#BinaryBuilderBase.runshell"><code>BinaryBuilderBase.runshell</code></a></li><li><a href="#BinaryBuilderBase.satisfied-Tuple{Product,Prefix}"><code>BinaryBuilderBase.satisfied</code></a></li><li><a href="#BinaryBuilderBase.setup_dependencies-Tuple{Prefix,Array{Pkg.Types.PackageSpec,1},Platform}"><code>BinaryBuilderBase.setup_dependencies</code></a></li><li><a href="#BinaryBuilderBase.setup_workspace-Tuple{AbstractString,Array{T,1} where T}"><code>BinaryBuilderBase.setup_workspace</code></a></li><li><a href="#BinaryBuilderBase.shard_mappings-Tuple{Array{CompilerShard,1}}"><code>BinaryBuilderBase.shard_mappings</code></a></li><li><a href="#BinaryBuilderBase.shard_path-Tuple{CompilerShard}"><code>BinaryBuilderBase.shard_path</code></a></li><li><a href="#BinaryBuilderBase.supported_microarchitectures-Tuple{Platform}"><code>BinaryBuilderBase.supported_microarchitectures</code></a></li><li><a href="#BinaryBuilderBase.supported_platforms-Tuple{}"><code>BinaryBuilderBase.supported_platforms</code></a></li><li><a href="#BinaryBuilderBase.temp_prefix-Tuple{Function}"><code>BinaryBuilderBase.temp_prefix</code></a></li><li><a href="#BinaryBuilderBase.uname-Tuple{}"><code>BinaryBuilderBase.uname</code></a></li><li><a href="#BinaryBuilderBase.unmount-Tuple{CompilerShard,String}"><code>BinaryBuilderBase.unmount</code></a></li><li><a href="#BinaryBuilderBase.variable_name-Tuple{Product}"><code>BinaryBuilderBase.variable_name</code></a></li><li><a href="#Pkg.PlatformEngines.package-Tuple{Prefix,AbstractString,VersionNumber}"><code>Pkg.PlatformEngines.package</code></a></li></ul><h2 id="Types-1"><a class="docs-heading-anchor" href="#Types-1">Types</a><a class="docs-heading-anchor-permalink" href="#Types-1" title="Permalink"></a></h2><article class="docstring"><header><a class="docstring-binding" id="BinaryBuilderBase.AbstractDependency" href="#BinaryBuilderBase.AbstractDependency"><code>BinaryBuilderBase.AbstractDependency</code></a> — <span class="docstring-category">Type</span></header><section><div><p>An <code>AbstractDependency</code> is a binary dependency of the JLL package.  Dependencies are installed to <code>${prefix}</code> in the build environment.</p><p>Concrete subtypes of <code>AbstractDependency</code> are</p><ul><li><a href="#BinaryBuilderBase.Dependency"><code>Dependency</code></a>: a JLL package that is necessary for to build the package and to load the generated JLL package.</li><li><a href="#BinaryBuilderBase.BuildDependency"><code>BuildDependency</code></a>: a JLL package that is necessary only to build the package.  This will not be a dependency of the generated JLL package.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaPackaging/BinaryBuilderBase.jl/blob/0257f55e25b2f0059651cf1a42c072e744391159/src/Dependencies.jl#L8-L18">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="BinaryBuilderBase.AbstractSource" href="#BinaryBuilderBase.AbstractSource"><code>BinaryBuilderBase.AbstractSource</code></a> — <span class="docstring-category">Type</span></header><section><div><p>An <code>AbstractSource</code> is something used as source to build the package.  Sources are installed to <code>${WORKSPACE}/srcdir</code> in the build environment.</p><p>Concrete subtypes of <code>AbstractSource</code> are:</p><ul><li><a href="#BinaryBuilderBase.ArchiveSource"><code>ArchiveSource</code></a>: a remote archive to download from the Internet;</li><li><a href="#BinaryBuilderBase.FileSource"><code>FileSource</code></a>: a remote file to download from the Internet;</li><li><a href="#BinaryBuilderBase.GitSource"><code>GitSource</code></a>: a remote Git repository to clone;</li><li><a href="#BinaryBuilderBase.DirectorySource"><code>DirectorySource</code></a>: a local directory to mount.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaPackaging/BinaryBuilderBase.jl/blob/0257f55e25b2f0059651cf1a42c072e744391159/src/Sources.jl#L5-L15">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="BinaryBuilderBase.AnyPlatform" href="#BinaryBuilderBase.AnyPlatform"><code>BinaryBuilderBase.AnyPlatform</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">AnyPlatform()</code></pre><p>A special platform to be used to build platform-independent tarballs, like those containing only header files.  <a href="#BinaryBuilderBase.FileProduct"><code>FileProduct</code></a> is the only product type allowed with this platform.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaPackaging/BinaryBuilderBase.jl/blob/0257f55e25b2f0059651cf1a42c072e744391159/src/Platforms.jl#L5-L11">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="BinaryBuilderBase.ArchiveSource" href="#BinaryBuilderBase.ArchiveSource"><code>BinaryBuilderBase.ArchiveSource</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">ArchiveSource(url::String, hash::String; unpack_target::String = &quot;&quot;)</code></pre><p>Specify a remote archive in one of the supported archive formats (e.g., TAR or ZIP balls) to be downloaded from the Internet from <code>url</code>.  <code>hash</code> is the 64-character SHA256 checksum of the file.</p><p>In the builder environment, the archive will be automatically unpacked to <code>${WORKSPACE}/srcdir</code>, or in its subdirectory pointed to by the optional keyword <code>unpack_target</code>, if provided.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaPackaging/BinaryBuilderBase.jl/blob/0257f55e25b2f0059651cf1a42c072e744391159/src/Sources.jl#L18-L28">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="BinaryBuilderBase.BuildDependency" href="#BinaryBuilderBase.BuildDependency"><code>BinaryBuilderBase.BuildDependency</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">BuildDependency(dep::Union{PackageSpec,String})</code></pre><p>Define a binary dependency that is necessary only to build the package.  The argument can be either a string with the name of the JLL package or a <code>Pkg.PackageSpec</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaPackaging/BinaryBuilderBase.jl/blob/0257f55e25b2f0059651cf1a42c072e744391159/src/Dependencies.jl#L33-L39">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="BinaryBuilderBase.Dependency" href="#BinaryBuilderBase.Dependency"><code>BinaryBuilderBase.Dependency</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">Dependency(dep::Union{PackageSpec,String})</code></pre><p>Define a binary dependency that is necessary to build the package and load the generated JLL package.  The argument can be either a string with the name of the JLL package or a <code>Pkg.PackageSpec</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaPackaging/BinaryBuilderBase.jl/blob/0257f55e25b2f0059651cf1a42c072e744391159/src/Dependencies.jl#L21-L27">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="BinaryBuilderBase.DirectorySource" href="#BinaryBuilderBase.DirectorySource"><code>BinaryBuilderBase.DirectorySource</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">DirectorySource(path::String; target::String = basename(path))</code></pre><p>Specify a local directory to mount from <code>path</code>.</p><p>The content of the directory will be mounted in <code>${WORKSPACE}/srcdir</code>, or in its subdirectory pointed to by the optional keyword <code>target</code>, if provided.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaPackaging/BinaryBuilderBase.jl/blob/0257f55e25b2f0059651cf1a42c072e744391159/src/Sources.jl#L78-L85">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="BinaryBuilderBase.DockerRunner" href="#BinaryBuilderBase.DockerRunner"><code>BinaryBuilderBase.DockerRunner</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">DockerRunner</code></pre><p>Use <code>docker</code> as an execution engine; a reasonable backup for platforms that do not have user namespaces (e.g. MacOS, Windows).</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaPackaging/BinaryBuilderBase.jl/blob/0257f55e25b2f0059651cf1a42c072e744391159/src/DockerRunner.jl#L1-L6">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="BinaryBuilderBase.ExecutableProduct" href="#BinaryBuilderBase.ExecutableProduct"><code>BinaryBuilderBase.ExecutableProduct</code></a> — <span class="docstring-category">Type</span></header><section><div><p>An <code>ExecutableProduct</code> is a <a href="#BinaryBuilderBase.Product"><code>Product</code></a> that represents an executable file.</p><p>On all platforms, an ExecutableProduct checks for existence of the file.  On non-Windows platforms, it will check for the executable bit being set.  On Windows platforms, it will check that the file ends with &quot;.exe&quot;, (adding it on automatically, if it is not already present).</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaPackaging/BinaryBuilderBase.jl/blob/0257f55e25b2f0059651cf1a42c072e744391159/src/Products.jl#L302-L309">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="BinaryBuilderBase.ExtendedPlatform" href="#BinaryBuilderBase.ExtendedPlatform"><code>BinaryBuilderBase.ExtendedPlatform</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">ExtendedPlatform(p::Platform; kwargs...)</code></pre><p>Extend a <code>Pkg.BinaryPlatforms.Platform</code> object with extra key-value mappings. Arbitrary <code>String</code> values are supported, with the following constraints:</p><ul><li>the key cannot be any of &quot;os&quot;, &quot;arch&quot;, &quot;libc&quot;, &quot;libgfortran<em>version&quot;, &quot;libstdcxx</em>version&quot;, &quot;cxxstring_abi&quot;;</li><li>if the key is called &quot;march&quot;, only specific values are allowed, depending on what is the base platform,</li><li>all strings should only use alphanumeric characters, the underscore, or the dot (the latter only for the value).</li></ul><p>This type is, for example, used to tag a standard platform from <code>Pkg.BinaryPlatforms</code> with additional features besides the C library or the compiler ABI.</p><pre><code class="language-julia-repl">julia&gt; using BinaryBuilderBase

julia&gt; ExtendedPlatform(Linux(:x86_64; libc=:glibc, compiler_abi=CompilerABI(; libgfortran_version=v&quot;4&quot;)); march = &quot;avx&quot;, cuda = &quot;9.2&quot;)
ExtendedPlatform(Linux(:x86_64, libc=:glibc, compiler_abi=CompilerABI(libgfortran_version=v&quot;4.0.0&quot;)); march=&quot;avx&quot;, cuda=&quot;9.2&quot;)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaPackaging/BinaryBuilderBase.jl/blob/0257f55e25b2f0059651cf1a42c072e744391159/src/Platforms.jl#L47-L70">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="BinaryBuilderBase.FileProduct" href="#BinaryBuilderBase.FileProduct"><code>BinaryBuilderBase.FileProduct</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">FileProduct(path::AbstractString, varname::Symbol, dir_path = nothing)</code></pre><p>Declares a <a href="#BinaryBuilderBase.FileProduct"><code>FileProduct</code></a> that points to a file located relative to the root of a <code>Prefix</code>, must simply exist to be satisfied.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaPackaging/BinaryBuilderBase.jl/blob/0257f55e25b2f0059651cf1a42c072e744391159/src/Products.jl#L409-L414">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="BinaryBuilderBase.FileSource" href="#BinaryBuilderBase.FileSource"><code>BinaryBuilderBase.FileSource</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">FileSource(url::String, hash::String; filename::String = basename(url))</code></pre><p>Specify a remote file to be downloaded from the Internet from <code>url</code>.  <code>hash</code> is the 64-character SHA256 checksum of the file.</p><p>In the builder environment, the file will be saved under <code>${WORKSPACE}/srcdir</code> with the same name as the basename of the originating URL, unless the the keyword argument <code>filename</code> is specified.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaPackaging/BinaryBuilderBase.jl/blob/0257f55e25b2f0059651cf1a42c072e744391159/src/Sources.jl#L43-L52">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="BinaryBuilderBase.FrameworkProduct" href="#BinaryBuilderBase.FrameworkProduct"><code>BinaryBuilderBase.FrameworkProduct</code></a> — <span class="docstring-category">Type</span></header><section><div><p>A <code>FrameworkProduct</code> is a  <a href="#BinaryBuilderBase.Product"><code>Product</code></a> that encapsulates a macOS Framework. It behaves mostly as a <a href="#BinaryBuilderBase.LibraryProduct"><code>LibraryProduct</code></a> for now, but is a distinct type. This implies that for cross-platform builds where a library is provided as a Framework on macOS and as a normal library on other platforms, two calls to <a href="@ref"><code>build_tarballs</code></a> are needed: one with the <code>LibraryProduct</code> and all non-macOS platforms, and one with the <code>FrameworkProduct</code> and the <code>MacOS</code> platforms.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaPackaging/BinaryBuilderBase.jl/blob/0257f55e25b2f0059651cf1a42c072e744391159/src/Products.jl#L229-L236">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="BinaryBuilderBase.GitSource" href="#BinaryBuilderBase.GitSource"><code>BinaryBuilderBase.GitSource</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">GitSource(url::String, hash::String; unpack_target::String = &quot;&quot;)</code></pre><p>Specify a remote Git repository to clone form <code>url</code>.  <code>hash</code> is the 40-character SHA1 revision to checkout after cloning.</p><p>The repository will be cloned in <code>${WORKSPACE}/srcdir</code>, or in its subdirectory pointed to by the optional keyword <code>unpack_target</code>, if provided.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaPackaging/BinaryBuilderBase.jl/blob/0257f55e25b2f0059651cf1a42c072e744391159/src/Sources.jl#L61-L69">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="BinaryBuilderBase.LibraryProduct" href="#BinaryBuilderBase.LibraryProduct"><code>BinaryBuilderBase.LibraryProduct</code></a> — <span class="docstring-category">Type</span></header><section><div><p>A <code>LibraryProduct</code> is a special kind of <a href="#BinaryBuilderBase.Product"><code>Product</code></a> that not only needs to exist, but needs to be <code>dlopen()</code>&#39;able.  You must know which directory the library will be installed to, and its name, e.g. to build a <code>LibraryProduct</code> that refers to <code>&quot;/lib/libnettle.so&quot;</code>, the &quot;directory&quot; would be &quot;/lib&quot;, and the &quot;libname&quot; would be &quot;libnettle&quot;.  Note that a <code>LibraryProduct</code> can support multiple libnames, as some software projects change the libname based on the build configuration.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaPackaging/BinaryBuilderBase.jl/blob/0257f55e25b2f0059651cf1a42c072e744391159/src/Products.jl#L69-L77">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="BinaryBuilderBase.Product" href="#BinaryBuilderBase.Product"><code>BinaryBuilderBase.Product</code></a> — <span class="docstring-category">Type</span></header><section><div><p>A <code>Product</code> is an expected result after building or installation of a package.</p><p>Examples of <code>Product</code>s include <a href="#BinaryBuilderBase.LibraryProduct"><code>LibraryProduct</code></a>, <a href="#BinaryBuilderBase.FrameworkProduct"><code>FrameworkProduct</code></a>, <a href="#BinaryBuilderBase.ExecutableProduct"><code>ExecutableProduct</code></a> and <a href="#BinaryBuilderBase.FileProduct"><code>FileProduct</code></a>. All <code>Product</code> types must define the following minimum set of functionality:</p><ul><li><p><a href="#BinaryBuilderBase.locate-Tuple{ExecutableProduct,Prefix}"><code>locate(::Product)</code></a>: given a <code>Product</code>, locate it within the wrapped <code>Prefix</code> returning its location as a string</p></li><li><p><a href="#BinaryBuilderBase.satisfied-Tuple{Product,Prefix}"><code>satisfied(::Product)</code></a>: given a <code>Product</code>, determine whether it has been successfully satisfied (e.g. it is locateable and it passes all callbacks)</p></li><li><p><a href="#BinaryBuilderBase.variable_name-Tuple{Product}"><code>variable_name(::Product)</code></a>: return the variable name assigned to a <code>Product</code></p></li><li><p><code>repr(::Product)</code>: Return a representation of this <code>Product</code>, useful for auto-generating source code that constructs <code>Products</code>, if that&#39;s your thing.</p></li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaPackaging/BinaryBuilderBase.jl/blob/0257f55e25b2f0059651cf1a42c072e744391159/src/Products.jl#L5-L24">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="BinaryBuilderBase.UserNSRunner" href="#BinaryBuilderBase.UserNSRunner"><code>BinaryBuilderBase.UserNSRunner</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">UserNSRunner</code></pre><p>A <code>UserNSRunner</code> represents an &quot;execution context&quot;, an object that bundles all necessary information to run commands within the container that contains our crossbuild environment.  Use <code>run()</code> to actually run commands within the <code>UserNSRunner</code>, and <a href="#BinaryBuilderBase.runshell"><code>runshell()</code></a> as a quick way to get an interactive shell within the crossbuild environment.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaPackaging/BinaryBuilderBase.jl/blob/0257f55e25b2f0059651cf1a42c072e744391159/src/UserNSRunner.jl#L3-L11">source</a></section></article><h2 id="Functions-1"><a class="docs-heading-anchor" href="#Functions-1">Functions</a><a class="docs-heading-anchor-permalink" href="#Functions-1" title="Permalink"></a></h2><article class="docstring"><header><a class="docstring-binding" id="BinaryBuilderBase.bindir-Tuple{Prefix}" href="#BinaryBuilderBase.bindir-Tuple{Prefix}"><code>BinaryBuilderBase.bindir</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">bindir(prefix::Prefix)</code></pre><p>Returns the binary directory for the given <code>prefix</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaPackaging/BinaryBuilderBase.jl/blob/0257f55e25b2f0059651cf1a42c072e744391159/src/Prefix.jl#L76-L80">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="BinaryBuilderBase.choose_shards-Tuple{Platform}" href="#BinaryBuilderBase.choose_shards-Tuple{Platform}"><code>BinaryBuilderBase.choose_shards</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">choose_shards(p::Platform; rootfs_build, ps_build, GCC_builds,
                           LLVM_builds, archive_type)</code></pre><p>This method chooses, given a <code>Platform</code>, which shards to download, extract and mount, returning a list of <code>CompilerShard</code> objects.  At the moment, this always consists of four shards, but that may not always be the case.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaPackaging/BinaryBuilderBase.jl/blob/0257f55e25b2f0059651cf1a42c072e744391159/src/Rootfs.jl#L454-L461">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="BinaryBuilderBase.compress_dir-Tuple{AbstractString}" href="#BinaryBuilderBase.compress_dir-Tuple{AbstractString}"><code>BinaryBuilderBase.compress_dir</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">compress_dir(dir::AbstractString;
             compressor_stream = GzipCompressorStream,
             level::Int = 9,
             extension::AbstractString = &quot;.gz&quot;,
             verbose::Bool = false)</code></pre><p>Compress all files in <code>dir</code> using the specified <code>compressor_stream</code> with compression level equal to <code>level</code>, appending <code>extension</code> to the filenames. Remove the original uncompressed files at the end.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaPackaging/BinaryBuilderBase.jl/blob/0257f55e25b2f0059651cf1a42c072e744391159/src/Prefix.jl#L470-L480">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="BinaryBuilderBase.download_source" href="#BinaryBuilderBase.download_source"><code>BinaryBuilderBase.download_source</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">download_source(source::AbstractSource; verbose::Bool = false)</code></pre><p>Download the given <code>source</code>.  All downloads are cached within the BinaryBuilder <code>downloads</code> storage directory.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaPackaging/BinaryBuilderBase.jl/blob/0257f55e25b2f0059651cf1a42c072e744391159/src/Sources.jl#L173-L178">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="BinaryBuilderBase.expand_cxxstring_abis-Tuple{Platform}" href="#BinaryBuilderBase.expand_cxxstring_abis-Tuple{Platform}"><code>BinaryBuilderBase.expand_cxxstring_abis</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">expand_cxxstring_abis(p::Platform)</code></pre><p>Given a <code>Platform</code>, returns an array of <code>Platforms</code> with a spread of identical entries with the exception of the <code>cxxstring_abi</code> member of the <code>CompilerABI</code> struct within the <code>Platform</code>.  This is used to take, for example, a list of supported platforms and expand them to include multiple GCC versions for the purposes of ABI matching.  If the given <code>Platform</code> already specifies a GCC version (as opposed to <code>nothing</code>) only that <code>Platform</code> is returned.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaPackaging/BinaryBuilderBase.jl/blob/0257f55e25b2f0059651cf1a42c072e744391159/src/Rootfs.jl#L634-L643">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="BinaryBuilderBase.expand_gfortran_versions-Tuple{Platform}" href="#BinaryBuilderBase.expand_gfortran_versions-Tuple{Platform}"><code>BinaryBuilderBase.expand_gfortran_versions</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">expand_gfortran_versions(p::Platform)</code></pre><p>Given a <code>Platform</code>, returns an array of <code>Platforms</code> with a spread of identical entries with the exception of the <code>gfortran_version</code> member of the <code>CompilerABI</code> struct within the <code>Platform</code>.  This is used to take, for example, a list of supported platforms and expand them to include multiple GCC versions for the purposes of ABI matching.  If the given <code>Platform</code> already specifies a GCC version (as opposed to <code>nothing</code>) only that <code>Platform</code> is returned.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaPackaging/BinaryBuilderBase.jl/blob/0257f55e25b2f0059651cf1a42c072e744391159/src/Rootfs.jl#L610-L619">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="BinaryBuilderBase.expand_microarchitectures-Tuple{Array{#s518,1} where #s518&lt;:Platform}" href="#BinaryBuilderBase.expand_microarchitectures-Tuple{Array{#s518,1} where #s518&lt;:Platform}"><code>BinaryBuilderBase.expand_microarchitectures</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">expand_microarchitectures(ps::Vector{&lt;:Platform})</code></pre><p>Expand all platforms in the given vector with the supported microarchitectures.</p><pre><code class="language-julia-repl">julia&gt; using BinaryBuilderBase

julia&gt; expand_microarchitectures(filter!(p -&gt; p isa Linux &amp;&amp; libc(p) == :glibc, supported_platforms()))
12-element Array{Platform,1}:
 Linux(:i686, libc=:glibc)
 ExtendedPlatform(Linux(:x86_64, libc=:glibc); march=&quot;avx&quot;)
 ExtendedPlatform(Linux(:x86_64, libc=:glibc); march=&quot;avx2&quot;)
 ExtendedPlatform(Linux(:x86_64, libc=:glibc); march=&quot;avx512&quot;)
 ExtendedPlatform(Linux(:x86_64, libc=:glibc); march=&quot;x86_64&quot;)
 ExtendedPlatform(Linux(:aarch64, libc=:glibc); march=&quot;armv8&quot;)
 ExtendedPlatform(Linux(:aarch64, libc=:glibc); march=&quot;carmel&quot;)
 ExtendedPlatform(Linux(:aarch64, libc=:glibc); march=&quot;thunderx2&quot;)
 ExtendedPlatform(Linux(:armv7l, libc=:glibc, call_abi=:eabihf); march=&quot;armv7l&quot;)
 ExtendedPlatform(Linux(:armv7l, libc=:glibc, call_abi=:eabihf); march=&quot;neon&quot;)
 ExtendedPlatform(Linux(:armv7l, libc=:glibc, call_abi=:eabihf); march=&quot;vfp4&quot;)
 Linux(:powerpc64le, libc=:glibc)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaPackaging/BinaryBuilderBase.jl/blob/0257f55e25b2f0059651cf1a42c072e744391159/src/Rootfs.jl#L733-L756">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="BinaryBuilderBase.expand_microarchitectures-Tuple{Platform}" href="#BinaryBuilderBase.expand_microarchitectures-Tuple{Platform}"><code>BinaryBuilderBase.expand_microarchitectures</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">expand_microarchitectures(p::Platform)</code></pre><p>Given a <code>Platform</code>, returns a vector of <code>Platforms</code> with a spread of identical <code>ExtendedPlatform</code> entries with the exception of the microarchitectures.  If the given <code>Platform</code> is already an <code>ExtendedPlatform</code> with a <code>march</code> feature, only that platform is returned.</p><p>Currently, only platforms with architecture <code>x86_64</code>, <code>amrv7l</code> or <code>aarch64</code> have supported microarchitectures.  If the architecture of the platform does not have supported microarchitectures, a 1-element vector containing the given platform is returned.</p><pre><code class="language-julia-repl">julia&gt; using BinaryBuilderBase

julia&gt; expand_microarchitectures(FreeBSD(:x86_64))
4-element Array{Platform,1}:
 ExtendedPlatform(FreeBSD(:x86_64); march=&quot;avx&quot;)
 ExtendedPlatform(FreeBSD(:x86_64); march=&quot;avx2&quot;)
 ExtendedPlatform(FreeBSD(:x86_64); march=&quot;avx512&quot;)
 ExtendedPlatform(FreeBSD(:x86_64); march=&quot;x86_64&quot;)

julia&gt; expand_microarchitectures(Linux(:armv7l))
3-element Array{Platform,1}:
 ExtendedPlatform(Linux(:armv7l, libc=:glibc, call_abi=:eabihf); march=&quot;armv7l&quot;)
 ExtendedPlatform(Linux(:armv7l, libc=:glibc, call_abi=:eabihf); march=&quot;neon&quot;)
 ExtendedPlatform(Linux(:armv7l, libc=:glibc, call_abi=:eabihf); march=&quot;vfp4&quot;)

julia&gt; expand_microarchitectures(Linux(:aarch64))
3-element Array{Platform,1}:
 ExtendedPlatform(Linux(:aarch64, libc=:glibc); march=&quot;armv8&quot;)
 ExtendedPlatform(Linux(:aarch64, libc=:glibc); march=&quot;carmel&quot;)
 ExtendedPlatform(Linux(:aarch64, libc=:glibc); march=&quot;thunderx2&quot;)

julia&gt; expand_microarchitectures(Windows(:i686))
1-element Array{Windows,1}:
 Windows(:i686)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaPackaging/BinaryBuilderBase.jl/blob/0257f55e25b2f0059651cf1a42c072e744391159/src/Rootfs.jl#L680-L719">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="BinaryBuilderBase.gcc_version-Tuple{Platform,Array{BinaryBuilderBase.GCCBuild,1}}" href="#BinaryBuilderBase.gcc_version-Tuple{Platform,Array{BinaryBuilderBase.GCCBuild,1}}"><code>BinaryBuilderBase.gcc_version</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">gcc_version(p::Platform, , GCC_builds::Vector{GCCBuild})</code></pre><p>Returns the closest matching GCC version number for the given particular platform, from the given set of options.  The compiler ABI and the microarchitecture of the platform will be taken into account.  If no match is found, returns an empty list.</p><p>This method assumes that the compiler ABI of the platform represents a platform that binaries will be run on, and thus versions are always rounded down; e.g. if the platform supports a <code>libstdc++</code> version that corresponds to <code>GCC 5.1.0</code>, but the only GCC versions available to be picked from are <code>4.8.5</code> and <code>5.2.0</code>, it will return <code>4.8.5</code>, as binaries compiled with that version will run on this platform, whereas binaries compiled with <code>5.2.0</code> may not.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaPackaging/BinaryBuilderBase.jl/blob/0257f55e25b2f0059651cf1a42c072e744391159/src/Rootfs.jl#L375-L389">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="BinaryBuilderBase.generate_compiler_wrappers!-Tuple{Platform}" href="#BinaryBuilderBase.generate_compiler_wrappers!-Tuple{Platform}"><code>BinaryBuilderBase.generate_compiler_wrappers!</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">generate_compiler_wrappers!(platform::Platform; bin_path::AbstractString,
                            host_platform::Platform = Linux(:x86_64; libc=:musl),
                            rust_platform::Platform = Linux(:x86_64; libc=:glibc),
                            compilers::Vector{Symbol} = [:c],
                            allow_unsafe_flags::Bool = false,
                            lock_microarchitecture::Bool = true)</code></pre><p>We generate a set of compiler wrapper scripts within our build environment to force all build systems to honor the necessary sets of compiler flags to build for our systems. Note that while <code>platform_envs()</code> sets many environment variables, those values are intended to be optional/overridable.  These values, while still overridable by directly invoking a compiler binary directly (e.g. /opt/{target}/bin/{target}-gcc), are much more difficult to override, as the flags embedded in these wrappers are absolutely necessary, and even simple programs will not compile without them.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaPackaging/BinaryBuilderBase.jl/blob/0257f55e25b2f0059651cf1a42c072e744391159/src/Runner.jl#L46-L61">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="BinaryBuilderBase.get_concrete_platform-Tuple{Platform,Array{CompilerShard,1}}" href="#BinaryBuilderBase.get_concrete_platform-Tuple{Platform,Array{CompilerShard,1}}"><code>BinaryBuilderBase.get_concrete_platform</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">get_concrete_platform(platform::Platform, shards::Vector{CompilerShard})</code></pre><p>Return the concrete platform for the given <code>platform</code> based on the GCC compiler ABI in the <code>shards</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaPackaging/BinaryBuilderBase.jl/blob/0257f55e25b2f0059651cf1a42c072e744391159/src/utils.jl#L17-L22">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="BinaryBuilderBase.get_concrete_platform-Tuple{Platform}" href="#BinaryBuilderBase.get_concrete_platform-Tuple{Platform}"><code>BinaryBuilderBase.get_concrete_platform</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">get_concrete_platform(platform::Platform;
                      preferred_gcc_version = nothing,
                      preferred_llvm_version = nothing,
                      compilers = nothing)</code></pre><p>Return the concrete platform for the given <code>platform</code> based on the GCC compiler ABI.  The set of shards is chosen by the keyword arguments (see <a href="#BinaryBuilderBase.choose_shards-Tuple{Platform}"><code>choose_shards</code></a>).</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaPackaging/BinaryBuilderBase.jl/blob/0257f55e25b2f0059651cf1a42c072e744391159/src/utils.jl#L43-L51">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="BinaryBuilderBase.includedir-Tuple{Prefix}" href="#BinaryBuilderBase.includedir-Tuple{Prefix}"><code>BinaryBuilderBase.includedir</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">includedir(prefix::Prefix)</code></pre><p>Returns the include directory for the given <code>prefix</code></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaPackaging/BinaryBuilderBase.jl/blob/0257f55e25b2f0059651cf1a42c072e744391159/src/Prefix.jl#L103-L107">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="BinaryBuilderBase.libdirs" href="#BinaryBuilderBase.libdirs"><code>BinaryBuilderBase.libdirs</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">libdirs(prefix::Prefix, platform = platform_key_abi())</code></pre><p>Returns the library directories for the given <code>prefix</code> (note that this differs between unix systems and windows systems, and between 32- and 64-bit systems).</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaPackaging/BinaryBuilderBase.jl/blob/0257f55e25b2f0059651cf1a42c072e744391159/src/Prefix.jl#L85-L90">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="BinaryBuilderBase.locate-Tuple{ExecutableProduct,Prefix}" href="#BinaryBuilderBase.locate-Tuple{ExecutableProduct,Prefix}"><code>BinaryBuilderBase.locate</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">locate(ep::ExecutableProduct, prefix::Prefix;
       platform::Platform = platform_key_abi(),
       verbose::Bool = false,
       isolate::Bool = false)</code></pre><p>If the given executable file exists and is executable, return its path.</p><p>On all platforms, an <a href="#BinaryBuilderBase.ExecutableProduct"><code>ExecutableProduct</code></a> checks for existence of the file.  On non-Windows platforms, it will check for the executable bit being set. On Windows platforms, it will check that the file ends with &quot;.exe&quot;, (adding it on automatically, if it is not already present).</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaPackaging/BinaryBuilderBase.jl/blob/0257f55e25b2f0059651cf1a42c072e744391159/src/Products.jl#L354-L366">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="BinaryBuilderBase.locate-Tuple{FileProduct,Prefix}" href="#BinaryBuilderBase.locate-Tuple{FileProduct,Prefix}"><code>BinaryBuilderBase.locate</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">locate(fp::FileProduct, prefix::Prefix;
       platform::Platform = platform_key_abi(),
       verbose::Bool = false,
       isolate::Bool = false)</code></pre><p>If the given file exists, return its path.  The <code>platform</code> and <code>isolate</code> arguments are is ignored here, but included for uniformity.  For ease of use, we support a limited number of custom variable expansions such as <code>${target}</code>, and <code>${nbits}</code>, so that the detection of files within target-specific folders named things like <code>/lib32/i686-linux-musl</code> is simpler.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaPackaging/BinaryBuilderBase.jl/blob/0257f55e25b2f0059651cf1a42c072e744391159/src/Products.jl#L432-L443">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="BinaryBuilderBase.locate-Tuple{LibraryProduct,Prefix}" href="#BinaryBuilderBase.locate-Tuple{LibraryProduct,Prefix}"><code>BinaryBuilderBase.locate</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">locate(lp::LibraryProduct, prefix::Prefix;
       verbose::Bool = false,
       platform::Platform = platform_key_abi())</code></pre><p>If the given library exists (under any reasonable name) and is <code>dlopen()</code>able, (assuming it was built for the current platform) return its location.  Note that the <code>dlopen()</code> test is only run if the current platform matches the given <code>platform</code> keyword argument, as cross-compiled libraries cannot be <code>dlopen()</code>ed on foreign platforms.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaPackaging/BinaryBuilderBase.jl/blob/0257f55e25b2f0059651cf1a42c072e744391159/src/Products.jl#L150-L160">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="BinaryBuilderBase.logdir-Tuple{Prefix}" href="#BinaryBuilderBase.logdir-Tuple{Prefix}"><code>BinaryBuilderBase.logdir</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">logdir(prefix::Prefix)</code></pre><p>Returns the logs directory for the given <code>prefix</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaPackaging/BinaryBuilderBase.jl/blob/0257f55e25b2f0059651cf1a42c072e744391159/src/Prefix.jl#L112-L116">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="BinaryBuilderBase.preferred_cxxstring_abi-Tuple{Platform,CompilerShard}" href="#BinaryBuilderBase.preferred_cxxstring_abi-Tuple{Platform,CompilerShard}"><code>BinaryBuilderBase.preferred_cxxstring_abi</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">preferred_cxxstring_abi(platform::Platform, shard::CompilerShard;
                        gcc_builds::Vector{GCCBuild} = available_gcc_builds)</code></pre><p>Return the C++ string ABI preferred by the given platform or GCCBootstrap shard.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaPackaging/BinaryBuilderBase.jl/blob/0257f55e25b2f0059651cf1a42c072e744391159/src/Rootfs.jl#L789-L794">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="BinaryBuilderBase.preferred_libgfortran_version-Tuple{Platform,CompilerShard}" href="#BinaryBuilderBase.preferred_libgfortran_version-Tuple{Platform,CompilerShard}"><code>BinaryBuilderBase.preferred_libgfortran_version</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">preferred_libgfortran_version(platform::Platform, shard::CompilerShard;
                              gcc_builds::Vector{GCCBuild} = available_gcc_builds)</code></pre><p>Return the libgfortran version preferred by the given platform or GCCBootstrap shard.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaPackaging/BinaryBuilderBase.jl/blob/0257f55e25b2f0059651cf1a42c072e744391159/src/Rootfs.jl#L759-L764">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="BinaryBuilderBase.satisfied-Tuple{Product,Prefix}" href="#BinaryBuilderBase.satisfied-Tuple{Product,Prefix}"><code>BinaryBuilderBase.satisfied</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">satisfied(p::Product;
          platform::Platform = platform_key_abi(),
          verbose::Bool = false,
          isolate::Bool = false)</code></pre><p>Given a <a href="#BinaryBuilderBase.Product"><code>Product</code></a>, return <code>true</code> if that <code>Product</code> is satisfied, e.g. whether a file exists that matches all criteria setup for that <code>Product</code>. If <code>isolate</code> is set to <code>true</code>, will isolate all checks from the main Julia process in the event that <code>dlopen()</code>&#39;ing a library might cause issues.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaPackaging/BinaryBuilderBase.jl/blob/0257f55e25b2f0059651cf1a42c072e744391159/src/Products.jl#L43-L53">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="BinaryBuilderBase.setup_dependencies-Tuple{Prefix,Array{Pkg.Types.PackageSpec,1},Platform}" href="#BinaryBuilderBase.setup_dependencies-Tuple{Prefix,Array{Pkg.Types.PackageSpec,1},Platform}"><code>BinaryBuilderBase.setup_dependencies</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">setup_dependencies(prefix::Prefix, dependencies::Vector{PackageSpec})</code></pre><p>Given a list of JLL package specifiers, install their artifacts into the build prefix. The artifacts are installed into the global artifact store, then copied into a temporary location, then finally symlinked into the build prefix.  This allows us to (a) save download bandwidth by not downloading the same artifacts over and over again, (b) maintain separation in the event of catastrophic containment failure, avoiding hosing the main system if a build script decides to try to modify the dependent artifact files, and (c) keeping a record of what files are a part of dependencies as opposed to the package being built, in the form of symlinks to a specific artifacts directory.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaPackaging/BinaryBuilderBase.jl/blob/0257f55e25b2f0059651cf1a42c072e744391159/src/Prefix.jl#L363-L374">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="BinaryBuilderBase.setup_workspace-Tuple{AbstractString,Array{T,1} where T}" href="#BinaryBuilderBase.setup_workspace-Tuple{AbstractString,Array{T,1} where T}"><code>BinaryBuilderBase.setup_workspace</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">setup_workspace(build_path::String, sources::Vector{SetupSource};
                verbose::Bool = false)</code></pre><p>Sets up a workspace within <code>build_path</code>, creating the directory structure needed by further steps, unpacking the source within <code>build_path</code>, and defining the environment variables that will be defined within the sandbox environment.</p><p>This method returns the <code>Prefix</code> to install things into, and the runner that can be used to launch commands within this workspace.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaPackaging/BinaryBuilderBase.jl/blob/0257f55e25b2f0059651cf1a42c072e744391159/src/Prefix.jl#L320-L330">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="BinaryBuilderBase.supported_platforms-Tuple{}" href="#BinaryBuilderBase.supported_platforms-Tuple{}"><code>BinaryBuilderBase.supported_platforms</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">supported_platforms(;exclude::Union{Vector{&lt;:Platform},Function}=x-&gt;false)</code></pre><p>Return the list of supported platforms as an array of <code>Platform</code>s.  These are the platforms we officially support building for, if you see a mapping in <code>get_shard_hash()</code> that isn&#39;t represented here, it&#39;s probably because that platform is still considered &quot;in beta&quot;.</p><p>Platforms can be excluded from the list by specifying an array of platforms to <code>exclude</code> i.e. <code>supported_platforms(exclude=[Windows(:i686),Windows(:x86_64)])</code> or a function that returns true for exclusions i.e.</p><pre><code class="language-none">islin(x) = typeof(x) == Linux
supported_platforms(exclude=islin)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaPackaging/BinaryBuilderBase.jl/blob/0257f55e25b2f0059651cf1a42c072e744391159/src/Rootfs.jl#L552-L566">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="BinaryBuilderBase.temp_prefix-Tuple{Function}" href="#BinaryBuilderBase.temp_prefix-Tuple{Function}"><code>BinaryBuilderBase.temp_prefix</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">temp_prefix(func::Function)</code></pre><p>Create a temporary prefix, passing the prefix into the user-defined function so that build/packaging operations can occur within the temporary prefix, which is then cleaned up after all operations are finished.  If the path provided exists already, it will be deleted.</p><p>Usage example:</p><pre><code class="language-none">out_path = abspath(&quot;./libfoo&quot;)
temp_prefix() do p
    # &lt;insert build steps here&gt;

    # tarball up the built package
    tarball_path, tarball_hash = package(p, out_path)
end</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaPackaging/BinaryBuilderBase.jl/blob/0257f55e25b2f0059651cf1a42c072e744391159/src/Prefix.jl#L10-L27">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="BinaryBuilderBase.variable_name-Tuple{Product}" href="#BinaryBuilderBase.variable_name-Tuple{Product}"><code>BinaryBuilderBase.variable_name</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">variable_name(p::Product)</code></pre><p>Return the variable name associated with this <a href="#BinaryBuilderBase.Product"><code>Product</code></a> as a string</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaPackaging/BinaryBuilderBase.jl/blob/0257f55e25b2f0059651cf1a42c072e744391159/src/Products.jl#L59-L63">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="BinaryBuilderBase.abi_agnostic-Union{Tuple{P}, Tuple{P}} where P&lt;:Platform" href="#BinaryBuilderBase.abi_agnostic-Union{Tuple{P}, Tuple{P}} where P&lt;:Platform"><code>BinaryBuilderBase.abi_agnostic</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">abi_agnostic(p::Platform)</code></pre><p>Strip out the CompilerABI portion of a Platform, making it &quot;ABI agnostic&quot;.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaPackaging/BinaryBuilderBase.jl/blob/0257f55e25b2f0059651cf1a42c072e744391159/src/Rootfs.jl#L51-L55">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="BinaryBuilderBase.accept_apple_sdk-Tuple{IO,IO}" href="#BinaryBuilderBase.accept_apple_sdk-Tuple{IO,IO}"><code>BinaryBuilderBase.accept_apple_sdk</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">accept_apple_sdk(ins::IO, outs::IO) -&gt; Bool</code></pre><p>Ask the user whether they accept the terms of the macOS SDK, and return a boolean with their choice.  Write messages to <code>outs</code>, read input from <code>ins</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaPackaging/BinaryBuilderBase.jl/blob/0257f55e25b2f0059651cf1a42c072e744391159/src/Rootfs.jl#L171-L176">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="BinaryBuilderBase.artifact_name-Tuple{CompilerShard}" href="#BinaryBuilderBase.artifact_name-Tuple{CompilerShard}"><code>BinaryBuilderBase.artifact_name</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">artifact_name(cs::CompilerShard)</code></pre><p>Return the bound artifact name for a particular shard.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaPackaging/BinaryBuilderBase.jl/blob/0257f55e25b2f0059651cf1a42c072e744391159/src/Rootfs.jl#L60-L64">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="BinaryBuilderBase.chown_cleanup-Tuple{DockerRunner}" href="#BinaryBuilderBase.chown_cleanup-Tuple{DockerRunner}"><code>BinaryBuilderBase.chown_cleanup</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">chown_cleanup(dr::DockerRunner)</code></pre><p>On Linux, the user id inside of the docker container doesn&#39;t correspond to ours on the outside, so permissions get all kinds of screwed up.  To fix this, we have to <code>chown -R $(id -u):$(id -g) $prefix</code>, which really sucks, but is still better than nothing.  This is why we prefer the UserNSRunner on Linux.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaPackaging/BinaryBuilderBase.jl/blob/0257f55e25b2f0059651cf1a42c072e744391159/src/DockerRunner.jl#L138-L145">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="BinaryBuilderBase.create_and_bind_mutable_artifact!-Tuple{Function,String}" href="#BinaryBuilderBase.create_and_bind_mutable_artifact!-Tuple{Function,String}"><code>BinaryBuilderBase.create_and_bind_mutable_artifact!</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">create_and_bind_mutable_artifact!(f::Function, art_name::String)</code></pre><p>Create (and bind) an artifact to <code>MutableArtifacts.toml</code> in one fell swoop. Used in things like .squashfs UID remapping and BB wizard state serialization.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaPackaging/BinaryBuilderBase.jl/blob/0257f55e25b2f0059651cf1a42c072e744391159/src/Rootfs.jl#L901-L906">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="BinaryBuilderBase.download_all_artifacts-Tuple{}" href="#BinaryBuilderBase.download_all_artifacts-Tuple{}"><code>BinaryBuilderBase.download_all_artifacts</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">download_all_shards(; verbose::Bool=false)</code></pre><p>Helper function to download all shards/helper binaries so that no matter what happens, you don&#39;t need an internet connection to build your precious, precious binaries.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaPackaging/BinaryBuilderBase.jl/blob/0257f55e25b2f0059651cf1a42c072e744391159/src/Rootfs.jl#L819-L825">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="BinaryBuilderBase.generate_per_uid_squashfs" href="#BinaryBuilderBase.generate_per_uid_squashfs"><code>BinaryBuilderBase.generate_per_uid_squashfs</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">generate_per_uid_squashfs(cs, new_uid = getuid())</code></pre><p>In order for the sandbox to work well, we need to have the uids of the squashfs images match the uid of the current unprivileged user.  Unfortunately there is no mount-time option to do this for us.  Fortunately, squashfs is simple enough that if the ID table is uncompressed, we can just manually patch the uids to be what we need.  This function performs this operation, by rewriting all UIDs and GIDs to the given <code>new_uid</code> (which defaults to the current user&#39;s UID)..</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaPackaging/BinaryBuilderBase.jl/blob/0257f55e25b2f0059651cf1a42c072e744391159/src/squashfs_utils.jl#L31-L40">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="BinaryBuilderBase.get_mutable_artifact_path-Tuple{String}" href="#BinaryBuilderBase.get_mutable_artifact_path-Tuple{String}"><code>BinaryBuilderBase.get_mutable_artifact_path</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">get_mutable_artifact_path(art_name::String)</code></pre><p>Convenience wrapper to get an artifact bound within <code>MutableArtifacts.toml</code>. Returns <code>nothing</code> if artifact not bound yet.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaPackaging/BinaryBuilderBase.jl/blob/0257f55e25b2f0059651cf1a42c072e744391159/src/Rootfs.jl#L913-L918">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="BinaryBuilderBase.getgid-Tuple{}" href="#BinaryBuilderBase.getgid-Tuple{}"><code>BinaryBuilderBase.getgid</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">getgid()</code></pre><p>Wrapper around libc&#39;s <code>getgid()</code> function</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaPackaging/BinaryBuilderBase.jl/blob/0257f55e25b2f0059651cf1a42c072e744391159/src/squashfs_utils.jl#L12-L16">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="BinaryBuilderBase.getuid-Tuple{}" href="#BinaryBuilderBase.getuid-Tuple{}"><code>BinaryBuilderBase.getuid</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">getuid()</code></pre><p>Wrapper around libc&#39;s <code>getuid()</code> function</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaPackaging/BinaryBuilderBase.jl/blob/0257f55e25b2f0059651cf1a42c072e744391159/src/squashfs_utils.jl#L3-L7">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="BinaryBuilderBase.import_docker_image-Tuple{CompilerShard,String}" href="#BinaryBuilderBase.import_docker_image-Tuple{CompilerShard,String}"><code>BinaryBuilderBase.import_docker_image</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">import_docker_image(rootfs::CompilerShard; verbose::Bool = false)</code></pre><p>Checks to see if the given rootfs has been imported into docker yet; if it hasn&#39;t, then do so so that we can run things like:</p><pre><code class="language-none">docker run -ti binarybuilder_rootfs:v2018.08.27 /bin/bash</code></pre><p>Which, after all, is the foundation upon which this whole doodad is built.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaPackaging/BinaryBuilderBase.jl/blob/0257f55e25b2f0059651cf1a42c072e744391159/src/DockerRunner.jl#L30-L39">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="BinaryBuilderBase.is_ecryptfs-Tuple{AbstractString}" href="#BinaryBuilderBase.is_ecryptfs-Tuple{AbstractString}"><code>BinaryBuilderBase.is_ecryptfs</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">is_ecryptfs(path::AbstractString; verbose::Bool=false)</code></pre><p>Checks to see if the given <code>path</code> (or any parent directory) is placed upon an <code>ecryptfs</code> mount.  This is known not to work on current kernels, see this bug for more details: https://bugzilla.kernel.org/show_bug.cgi?id=197603</p><p>This method returns whether it is encrypted or not, and what mountpoint it used to make that decision.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaPackaging/BinaryBuilderBase.jl/blob/0257f55e25b2f0059651cf1a42c072e744391159/src/UserNSRunner.jl#L403-L412">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="BinaryBuilderBase.is_mounted-Tuple{CompilerShard,AbstractString}" href="#BinaryBuilderBase.is_mounted-Tuple{CompilerShard,AbstractString}"><code>BinaryBuilderBase.is_mounted</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">is_mounted(cs::CompilerShard, build_prefix::String)</code></pre><p>Return true if the given shard is mounted.  Uses <code>run()</code> so will error out if something goes awry.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaPackaging/BinaryBuilderBase.jl/blob/0257f55e25b2f0059651cf1a42c072e744391159/src/Rootfs.jl#L273-L278">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="BinaryBuilderBase.macos_sdk_already_installed-Tuple{}" href="#BinaryBuilderBase.macos_sdk_already_installed-Tuple{}"><code>BinaryBuilderBase.macos_sdk_already_installed</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">macos_sdk_already_installed()</code></pre><p>Returns <code>true</code> if any piece of the MacOS SDK is already installed.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaPackaging/BinaryBuilderBase.jl/blob/0257f55e25b2f0059651cf1a42c072e744391159/src/Rootfs.jl#L313-L317">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="BinaryBuilderBase.map_target-Tuple{CompilerShard}" href="#BinaryBuilderBase.map_target-Tuple{CompilerShard}"><code>BinaryBuilderBase.map_target</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">map_target(cs::CompilerShard)</code></pre><p>Return the location this compiler shard should be mounted at.  We basically analyze the name and platform of this shard and return a path based on that.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaPackaging/BinaryBuilderBase.jl/blob/0257f55e25b2f0059651cf1a42c072e744391159/src/Rootfs.jl#L140-L145">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="BinaryBuilderBase.mount-Tuple{CompilerShard,AbstractString}" href="#BinaryBuilderBase.mount-Tuple{CompilerShard,AbstractString}"><code>BinaryBuilderBase.mount</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">mount(cs::CompilerShard, build_prefix::String)</code></pre><p>Mount a compiler shard, if possible.  Uses <code>run()</code> so will error out if something goes awry.  Note that this function only does something when using a <code>.squashfs</code> shard, with a UserNS or Docker runner, on Linux. All other combinations of shard archive type, runner and platform result in a no-op from this function.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaPackaging/BinaryBuilderBase.jl/blob/0257f55e25b2f0059651cf1a42c072e744391159/src/Rootfs.jl#L200-L208">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="BinaryBuilderBase.platform_envs-Tuple{Platform,AbstractString}" href="#BinaryBuilderBase.platform_envs-Tuple{Platform,AbstractString}"><code>BinaryBuilderBase.platform_envs</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">platform_envs(platform::Platform)</code></pre><p>Given a <code>platform</code>, generate a <code>Dict</code> mapping representing all the environment variables to be set within the build environment to force compiles toward the defined target architecture.  Examples of things set are <code>PATH</code>, <code>CC</code>, <code>RANLIB</code>, as well as nonstandard things like <code>target</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaPackaging/BinaryBuilderBase.jl/blob/0257f55e25b2f0059651cf1a42c072e744391159/src/Runner.jl#L534-L541">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="BinaryBuilderBase.runshell" href="#BinaryBuilderBase.runshell"><code>BinaryBuilderBase.runshell</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">runshell(platform::Platform = platform_key_abi())</code></pre><p>Launch an interactive shell session within the user namespace, with environment setup to target the given <code>platform</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaPackaging/BinaryBuilderBase.jl/blob/0257f55e25b2f0059651cf1a42c072e744391159/src/Runner.jl#L750-L755">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="BinaryBuilderBase.shard_mappings-Tuple{Array{CompilerShard,1}}" href="#BinaryBuilderBase.shard_mappings-Tuple{Array{CompilerShard,1}}"><code>BinaryBuilderBase.shard_mappings</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">shard_mappings(shards::Vector{CompilerShard})</code></pre><p>Return the default mappings for a set of compiler shards</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaPackaging/BinaryBuilderBase.jl/blob/0257f55e25b2f0059651cf1a42c072e744391159/src/Rootfs.jl#L864-L868">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="BinaryBuilderBase.shard_path-Tuple{CompilerShard}" href="#BinaryBuilderBase.shard_path-Tuple{CompilerShard}"><code>BinaryBuilderBase.shard_path</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">shard_path(cs::CompilerShard)</code></pre><p>Return the path to this shard on-disk; for unpacked shards, this is a directory. For squashfs shards, this is a file.  This will not cause a shard to be downloaded.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaPackaging/BinaryBuilderBase.jl/blob/0257f55e25b2f0059651cf1a42c072e744391159/src/Rootfs.jl#L111-L116">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="BinaryBuilderBase.supported_microarchitectures-Tuple{Platform}" href="#BinaryBuilderBase.supported_microarchitectures-Tuple{Platform}"><code>BinaryBuilderBase.supported_microarchitectures</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">supported_microarchitectures(p::Platform)</code></pre><p>Return a vector with the list of supported microarchitectures for the given platform, an empty vector if there are any.  If <code>p</code> is an <a href="#BinaryBuilderBase.ExtendedPlatform"><code>ExtendedPlatform</code></a> which already specifies a microarchitecture, returns a 1-element vector containing only that one.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaPackaging/BinaryBuilderBase.jl/blob/0257f55e25b2f0059651cf1a42c072e744391159/src/Rootfs.jl#L660-L667">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="BinaryBuilderBase.uname-Tuple{}" href="#BinaryBuilderBase.uname-Tuple{}"><code>BinaryBuilderBase.uname</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">uname()</code></pre><p>On Linux systems, return the strings returned by the <code>uname()</code> function in libc</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaPackaging/BinaryBuilderBase.jl/blob/0257f55e25b2f0059651cf1a42c072e744391159/src/UserNSRunner.jl#L233-L237">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="BinaryBuilderBase.unmount-Tuple{CompilerShard,String}" href="#BinaryBuilderBase.unmount-Tuple{CompilerShard,String}"><code>BinaryBuilderBase.unmount</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">unmount(cs::CompilerShard, build_prefix::String)</code></pre><p>Unmount a compiler shard from a given build prefix, if possible.  Uses <code>run()</code> so will error out if something goes awry.  Note that this function only does something when using a squashfs shard on Linux.  All other combinations of shard archive type and platform result in a no-op.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaPackaging/BinaryBuilderBase.jl/blob/0257f55e25b2f0059651cf1a42c072e744391159/src/Rootfs.jl#L283-L290">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Pkg.PlatformEngines.package-Tuple{Prefix,AbstractString,VersionNumber}" href="#Pkg.PlatformEngines.package-Tuple{Prefix,AbstractString,VersionNumber}"><code>Pkg.PlatformEngines.package</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">package(prefix::Prefix, output_base::AbstractString,
        version::VersionNumber;
        platform::Platform = platform_key_abi(),
        verbose::Bool = false, force::Bool = false)</code></pre><p>Build a tarball of the <code>prefix</code>, storing the tarball at <code>output_base</code>, appending a version number, a platform-dependent suffix and a file extension. If no platform is given, defaults to current platform. Returns the full path to, the SHA256 hash and the git tree SHA1 of the generated tarball.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaPackaging/BinaryBuilderBase.jl/blob/0257f55e25b2f0059651cf1a42c072e744391159/src/Prefix.jl#L121-L131">source</a></section></article></article></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> on <span class="colophon-date" title="Thursday 25 June 2020 21:22">Thursday 25 June 2020</span>. Using Julia version 1.4.2.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
