using BinaryProvider
using BinDeps2
using Base.Test
using SHA
using Compat

# The platform we're running on
const platform = platform_key()

# On windows, the `.exe` extension is very important
const exe_ext = is_windows() ? ".exe" : ""

# We are going to build/install libfoo a lot, so here's our function to make sure the
# library is working properly
function check_foo(fooifier_path = "fooifier$(exe_ext)",
                   libfoo_path = "libfoo.$(Libdl.dlext)")
    # We know that foo(a, b) returns 2*a^2 - b
    result = 2*2.2^2 - 1.1

    # Test that we can invoke fooifier
    @test !success(`$fooifier_path`)
    @test success(`$fooifier_path 1.5 2.0`)
    @test parse(Float64,readchomp(`$fooifier_path 2.2 1.1`)) ≈ result

    # Test that we can dlopen() libfoo and invoke it directly
    libfoo = Libdl.dlopen_e(libfoo_path)
    @test libfoo != C_NULL
    foo = Libdl.dlsym_e(libfoo, :foo)
    @test foo != C_NULL
    @test ccall(foo, Cdouble, (Cdouble, Cdouble), 2.2, 1.1) ≈ result
    Libdl.dlclose(libfoo)
end

# This file contains tests that require our cross-compilation environment
@testset "Builder Dependency" begin
    temp_prefix() do prefix
        # First, let's create a Dependency that just installs a file
        cd("build_tests") do
            # Our simple executable file, generated by bash
            test_exe = FileResult(joinpath(bindir(prefix),"test_exe"))
            results = [test_exe]

            # Remember that we don't need to use `bash()` here because these commands
            # will be happening within the cross-compilation environment
            cmds = Cmd[]
            push!(cmds, `mkdir -p $(bindir(prefix))`)
            push!(cmds, `bash -c "printf '#!/bin/bash\necho test' > $(test_exe.path)"`)
            push!(cmds, `chmod 775 $(test_exe.path)`)
            
            dep = Dependency("bash_test", results, cmds, platform, prefix)

            @test build(dep; verbose=true)
            @test satisfied(dep)
            @test readstring(`$(test_exe.path)`) == "test\n"
        end

        # Next, build a simple shared library and an executable
        cd("build_tests/libfoo") do
            libfoo = LibraryResult(joinpath(libdir(prefix), "libfoo"))
            fooifier = FileResult(joinpath(bindir(prefix), "fooifier"))
            steps = [`make clean`, `make install`]
            dep = Dependency("foo", [libfoo, fooifier], steps, platform, prefix)

            # Build it
            @test build(dep; verbose=true)
            @test satisfied(dep; verbose=true)

            # Test the binaries
            check_foo(fooifier.path, libfoo.path)

            # Also test the binaries through `activate()`
            activate(prefix)
            check_foo()
            deactivate(prefix)

            # Test that `collect_files()` works:
            all_files = collect_files(prefix)
            @test libfoo.path in all_files
            @test fooifier.path in all_files
        end
    end

    temp_prefix() do prefix
        # Next, work in two layers of dependencies.  We'll build `libfoo` just like
        # above, but we'll explicitly model `fooifier` as a separate, Dependency
        cd("build_tests/libfoo") do
            libfoo = LibraryResult(joinpath(libdir(prefix), "libfoo"))
            cmds = [`make install-libfoo`]
            dep_libfoo = Dependency("libfoo", [libfoo], cmds, platform, prefix)

            fooifier = FileResult(joinpath(bindir(prefix), "fooifier"))
            cmds = [`make install-fooifier`]
            dep_fooifier = Dependency("fooifier", [fooifier], cmds, platform, prefix, [dep_libfoo])

            # Build fooifier, which should invoke libfoo automagically
            @test build(dep_fooifier; verbose=true)

            # Test the binaries
            check_foo(fooifier.path, libfoo.path)

            # Make sure once it's built, it doesn't auto-build again
            info("The following two builds should not need to be run")
            build(dep_fooifier; verbose=true)
        end
    end
end

@testset "Builder Packaging" begin
    # Clear out previous build products
    for f in readdir(".")
        if !endswith(f, ".tar.gz")
            continue
        end
        rm(f; force=true)
    end

    # Gotta set this guy up beforehand
    tarball_path = nothing

    temp_prefix() do prefix
        cd("build_tests/libfoo") do
            # First, build libfoo
            libfoo = LibraryResult(joinpath(libdir(prefix), "libfoo"))
            fooifier = FileResult(joinpath(bindir(prefix), "fooifier"))
            steps = [`make clean`, `make install`]
            dep = Dependency("foo", [libfoo, fooifier], steps, platform, prefix)

            @test build(dep)
        end    
        
        # Next, package it up as a .tar.gz file
        tarball_path = package(prefix, "./libfoo"; verbose=true)
        @test isfile(tarball_path)
    end

    libfoo_hash = open(tarball_path, "r") do f
        bytes2hex(sha256(f))
    end

    # Test that we can inspect the contents of the tarball
    contents = list_tarball_files(tarball_path)
    @test "bin/fooifier" in contents
    @test "lib/libfoo.$(Libdl.dlext)" in contents

    # Install it within a new Prefix
    temp_prefix() do prefix
        # Install the thing
        @test install(tarball_path, libfoo_hash; prefix=prefix, verbose=true)

        # Ensure we can use it
        fooifier_path = joinpath(bindir(prefix), "fooifier")
        libfoo_path = joinpath(libdir(prefix), "libfoo.$(Libdl.dlext)")
        check_foo(fooifier_path, libfoo_path)
    end

    rm(tarball_path; force=true)
end

@testset "Build Nettle" begin
    temp_prefix() do prefix
        # Some useful directories
        src_path = joinpath(prefix, "src")
        build_path = joinpath(prefix, "build")
        try mkpath(src_path) end
        try mkpath(build_path) end

        # First, download the sources, store them into /src
        src_url = "https://ftp.gnu.org/gnu/nettle/nettle-3.3.tar.gz"
        src_hash = "46942627d5d0ca11720fec18d81fc38f7ef837ea4197c1f630e71ce0d470b11e"        
        download_verify_unpack(src_url, src_hash, src_path; verbose=true)

        # Copy in our nettle build script to /build
        cp(joinpath("build_tests", "nettle", "build_nettle.sh"), joinpath(build_path,"build_nettle.sh"))

        # Build for many platforms
        for platform in supported_platforms()
            cd(build_path) do
                target = platform_triplet(platform)
                libnettle = LibraryResult(joinpath(libdir(prefix), target, "libnettle"))
                nettlehash = FileResult(joinpath(bindir(prefix), target, "nettle-hash"))

                steps = [`bash ./build_nettle.sh $(prefix.path)`]
                dep = Dependency("nettle", [libnettle, nettlehash], steps, platform, prefix)
                build(dep; verbose=true)
            end
        end
    end
end